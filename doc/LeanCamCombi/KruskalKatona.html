<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href=".././style.css"></link><link rel="stylesheet" href=".././src/pygments.css"></link><link rel="shortcut icon" href=".././favicon.ico"></link><link rel="prefetch" href=".././/declarations/declaration-data.bmp" as="image"></link><title>LeanCamCombi.KruskalKatona</title><script defer="true" src=".././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT=".././";</script><script>const MODULE_NAME="LeanCamCombi.KruskalKatona";</script><script type="module" src=".././jump-src.js"></script><script type="module" src=".././search.js"></script><script type="module" src=".././expand-nav.js"></script><script type="module" src=".././how-about.js"></script><script type="module" src=".././instances.js"></script><script type="module" src=".././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within"><span class="name">LeanCamCombi</span>.<span class="name">KruskalKatona</span></p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top"><span class="name">LeanCamCombi</span>.<span class="name">KruskalKatona</span></a></h3><p class="gh_nav_link"><a href="https://github.com/YaelDillies/LeanCamCombi/blob/41ed909d6e8b5e6b618db6412ed63ba09eba61c3//LeanCamCombi/KruskalKatona.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href=".././Init.html">Init</a></li><li><a href=".././Mathlib/Algebra/GeomSum.html">Mathlib.Algebra.GeomSum</a></li><li><a href=".././LeanCamCombi/Mathlib/Combinatorics/Colex.html">LeanCamCombi.Mathlib.Combinatorics.Colex</a></li><li><a href=".././LeanCamCombi/Mathlib/Order/RelClasses.html">LeanCamCombi.Mathlib.Order.RelClasses</a></li><li><a href=".././Mathlib/Combinatorics/SetFamily/Intersecting.html">Mathlib.Combinatorics.SetFamily.Intersecting</a></li><li><a href=".././Mathlib/Data/Finset/Fin.html">Mathlib.Data.Finset.Fin</a></li><li><a href=".././Mathlib/Data/Finset/Sort.html">Mathlib.Data.Finset.Sort</a></li><li><a href=".././LeanCamCombi/Mathlib/Combinatorics/SetFamily/Shadow.html">LeanCamCombi.Mathlib.Combinatorics.SetFamily.Shadow</a></li><li><a href=".././LeanCamCombi/Mathlib/Data/Finset/Sups.html">LeanCamCombi.Mathlib.Data.Finset.Sups</a></li><li><a href=".././LeanCamCombi/Mathlib/Combinatorics/SetFamily/Compression/UV.html">LeanCamCombi.Mathlib.Combinatorics.SetFamily.Compression.UV</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-LeanCamCombi.KruskalKatona" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Finset.Wolex.shadow_initSeg"><span class="name">Finset</span>.<span class="name">Wolex</span>.<span class="name">shadow_initSeg</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.Wolex.IsInitSeg.shadow"><span class="name">Finset</span>.<span class="name">Wolex</span>.<span class="name">IsInitSeg</span>.<span class="name">shadow</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.UW.toWolex_compress_lt_toWolex"><span class="name">Finset</span>.<span class="name">UW</span>.<span class="name">toWolex_compress_lt_toWolex</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.UW.UsefulCompression.instDecidableRel"><span class="name">Finset</span>.<span class="name">UW</span>.<span class="name">UsefulCompression</span>.<span class="name">instDecidableRel</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.UW.compression_improved"><span class="name">Finset</span>.<span class="name">UW</span>.<span class="name">compression_improved</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.UW.isInitSeg_of_compressed"><span class="name">Finset</span>.<span class="name">UW</span>.<span class="name">isInitSeg_of_compressed</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.UW.familyMeasure_compression_lt_familyMeasure"><span class="name">Finset</span>.<span class="name">UW</span>.<span class="name">familyMeasure_compression_lt_familyMeasure</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.kruskal_katona"><span class="name">Finset</span>.<span class="name">kruskal_katona</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.strengthened_kk"><span class="name">Finset</span>.<span class="name">strengthened_kk</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.iterated_kk"><span class="name">Finset</span>.<span class="name">iterated_kk</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.lovasz_form"><span class="name">Finset</span>.<span class="name">lovasz_form</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.EKR"><span class="name">Finset</span>.<span class="name">EKR</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Kruskal-Katona-theorem">Kruskal-Katona theorem <a class="hover-link" href="#Kruskal-Katona-theorem">#</a></h1><p>The Kruskal-Katona theorem in a few different versions, and an application to
the Erdos-Ko-Rado theorem.</p><p>The key results proved here are:</p><ul>
<li>The basic Kruskal-Katona theorem, expressing that given a set family ğ’œ
consisting of <code>r</code>-sets, and ğ’ an initial segment of the wolex order of the
same size, the shadow of ğ’ is smaller than the shadow of ğ’œ.
In particular, this shows that the minimum shadow size is achieved by initial
segments of wolex.</li>
</ul><p>lemma kruskal_katona {r : â„•} {ğ’œ ğ’ : Finset (Finset (Fin n))} (hâ‚ : (ğ’œ : set (Finset Î±)).Sized r)
(hâ‚‚ : ğ’œ.card = ğ’.card) (hâ‚ƒ : IsInitSeg ğ’ r) :
(âˆ‚ğ’).card â‰¤ (âˆ‚ğ’œ).card :=</p><ul>
<li>A strengthened form, giving the same result under a weaker constraint.</li>
</ul><p>lemma strengthened_kk {r : â„•} {ğ’œ ğ’ : Finset (Finset (Fin n))} (hâ‚ : (ğ’œ : set (Finset Î±)).Sized r)
(hâ‚‚ : ğ’.card â‰¤ ğ’œ.card) (hâ‚ƒ : IsInitSeg ğ’ r) :
(âˆ‚ğ’).card â‰¤ (âˆ‚ğ’œ).card :=</p><ul>
<li>An iterated form, giving that the minimum iterated shadow size is given
by initial segments of wolex.</li>
</ul><p>lemma iterated_kk {r k : â„•} {ğ’œ ğ’ : Finset (Finset (Fin n))} (hâ‚ : (ğ’œ : set (Finset Î±)).Sized r)
(hâ‚‚ : ğ’.card â‰¤ ğ’œ.card) (hâ‚ƒ : IsInitSeg ğ’ r) :
(âˆ‚^[k] ğ’).card â‰¤ (âˆ‚^[k] ğ’œ).card :=</p><ul>
<li>A special case of iterated_kk which is often more practical to use.</li>
</ul><p>lemma lovasz_form {r k i : â„•} {ğ’œ : Finset (Finset (Fin n))} (hir : i â‰¤ r)
(hrk : r â‰¤ k) (hkn : k â‰¤ n) (hâ‚ : (ğ’œ : set (Finset Î±)).Sized r) (hâ‚‚ : choose k r â‰¤ ğ’œ.card) :
choose k (r-i) â‰¤ (âˆ‚^[i] ğ’œ).card :=</p><ul>
<li>Erdos-Ko-Rado theorem, giving the upper bound on the size of an intersecting
family of <code>r</code>-sets</li>
</ul><p>lemma EKR {ğ’œ : Finset (Finset (Fin n))} {r : â„•}
(hâ‚ : intersecting ğ’œ) (hâ‚‚ : (ğ’œ : set (Finset Î±)).Sized r) (hâ‚ƒ : r â‰¤ n/2) :
ğ’œ.card â‰¤ choose (n-1) (r-1) :=</p><h2 class="markdown-heading" id="TODO">TODO <a class="hover-link" href="#TODO">#</a></h2><ul>
<li>Define the <code>k</code>-cascade representation of a natural and prove the corresponding version of
Kruskal-Katona.</li>
<li>Abstract away from <code><a href=".././Init/Prelude.html#Fin">Fin</a> n</code> so that it also applies to <code>â„•</code>. Probably <code><a href=".././Mathlib/Order/LocallyFinite.html#LocallyFiniteOrderBot">LocallyFiniteOrderBot</a></code>
will help here.</li>
<li>Characterise the equality case.</li>
</ul><h2 class="markdown-heading" id="References">References <a class="hover-link" href="#References">#</a></h2><ul>
<li>http://b-mehta.github.io/maths-notes/iii/mich/combinatorics.pdf</li>
<li>http://discretemath.imp.fu-berlin.de/DMII-2015-16/kruskal.pdf</li>
</ul><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>kruskal-katona, kruskal, katona, shadow, initial segments, intersecting</p></div><div class="decl" id="Finset.Wolex.shadow_initSeg"><div class="theorem"><div class="gh_link"><a href="https://github.com/YaelDillies/LeanCamCombi/blob/41ed909d6e8b5e6b618db6412ed63ba09eba61c3//LeanCamCombi/KruskalKatona.lean#L87-L170">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././LeanCamCombi/KruskalKatona.html#Finset.Wolex.shadow_initSeg"><span class="name">Finset</span>.<span class="name">Wolex</span>.<span class="name">shadow_initSeg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Î± : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">Î±</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hs : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset.Nonempty">Finset.Nonempty</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Mathlib/Combinatorics/SetFamily/Shadow.html#Finset.shadow">Finset.shadow</a> (<span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/Colex.html#Finset.Wolex.initSeg">Finset.Wolex.initSeg</a> <span class="fn">s</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/Colex.html#Finset.Wolex.initSeg">Finset.Wolex.initSeg</a> (<span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset.erase">Finset.erase</a> <span class="fn">s</span> (<span class="fn"><a href=".././Mathlib/Data/Finset/Lattice.html#Finset.min'">Finset.min'</a> <span class="fn">s</span> <span class="fn">hs</span></span>)</span>)</span></span></div></div><p>This is important for iterating Kruskal-Katona: the shadow of an initial segment is also an
initial segment.</p></div></div><div class="decl" id="Finset.Wolex.IsInitSeg.shadow"><div class="theorem"><div class="gh_link"><a href="https://github.com/YaelDillies/LeanCamCombi/blob/41ed909d6e8b5e6b618db6412ed63ba09eba61c3//LeanCamCombi/KruskalKatona.lean#L173-L184">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././LeanCamCombi/KruskalKatona.html#Finset.Wolex.IsInitSeg.shadow"><span class="name">Finset</span>.<span class="name">Wolex</span>.<span class="name">IsInitSeg</span>.<span class="name">shadow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Î± : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ğ’œ : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">Î±</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Mathlib/Data/Finite/Defs.html#Finite">Finite</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hâ‚ : <span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/Colex.html#Finset.Wolex.IsInitSeg">Finset.Wolex.IsInitSeg</a> <span class="fn">ğ’œ</span> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/Colex.html#Finset.Wolex.IsInitSeg">Finset.Wolex.IsInitSeg</a> (<span class="fn"><a href=".././Mathlib/Combinatorics/SetFamily/Shadow.html#Finset.shadow">Finset.shadow</a> <span class="fn">ğ’œ</span></span>) (<span class="fn"><span class="fn">r</span> <a href=".././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></span>)</span></div></div><p>The shadow of an initial segment is also an initial segment.</p></div></div><div class="decl" id="Finset.UW.toWolex_compress_lt_toWolex"><div class="theorem"><div class="gh_link"><a href="https://github.com/YaelDillies/LeanCamCombi/blob/41ed909d6e8b5e6b618db6412ed63ba09eba61c3//LeanCamCombi/KruskalKatona.lean#L197-L205">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././LeanCamCombi/KruskalKatona.html#Finset.UW.toWolex_compress_lt_toWolex"><span class="name">Finset</span>.<span class="name">UW</span>.<span class="name">toWolex_compress_lt_toWolex</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Î± : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">Î±</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">Î±</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">Î±</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{hU : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset.Nonempty">Finset.Nonempty</a> <span class="fn">U</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{hV : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset.Nonempty">Finset.Nonempty</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href=".././Mathlib/Data/Finset/Lattice.html#Finset.max'">Finset.max'</a> <span class="fn">U</span> <span class="fn">hU</span></span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href=".././Mathlib/Data/Finset/Lattice.html#Finset.max'">Finset.max'</a> <span class="fn">V</span> <span class="fn">hV</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hA : <span class="fn"><span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/SetFamily/Compression/UV.html#UW.compress">UW.compress</a> <span class="fn">U</span> <span class="fn">V</span> <span class="fn">s</span></span> <a href=".././Init/Core.html#Ne">â‰ </a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">â†‘<span class="fn">Finset.toWolex</span> (<span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/SetFamily/Compression/UV.html#UW.compress">UW.compress</a> <span class="fn">U</span> <span class="fn">V</span> <span class="fn">s</span></span>)</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">â†‘<span class="fn">Finset.toWolex</span> <span class="fn">s</span></span></span></div></div><p>Applying the compression makes the set smaller in wolex. This is intuitive since a portion of
the set is being "shifted 'down" as <code>max U < max V</code>.</p></div></div><div class="decl" id="Finset.UW.UsefulCompression.instDecidableRel"><div class="instance"><div class="gh_link"><a href="https://github.com/YaelDillies/LeanCamCombi/blob/41ed909d6e8b5e6b618db6412ed63ba09eba61c3//LeanCamCombi/KruskalKatona.lean#L211-L212">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././LeanCamCombi/KruskalKatona.html#Finset.UW.UsefulCompression.instDecidableRel"><span class="name">Finset</span>.<span class="name">UW</span>.<span class="name">UsefulCompression</span>.<span class="name">instDecidableRel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Î± : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">Finset.UW.UsefulCompression</span></span></div></div></div></div><div class="decl" id="Finset.UW.compression_improved"><div class="theorem"><div class="gh_link"><a href="https://github.com/YaelDillies/LeanCamCombi/blob/41ed909d6e8b5e6b618db6412ed63ba09eba61c3//LeanCamCombi/KruskalKatona.lean#L217-L235">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././LeanCamCombi/KruskalKatona.html#Finset.UW.compression_improved"><span class="name">Finset</span>.<span class="name">UW</span>.<span class="name">compression_improved</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Î± : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">Î±</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">Î±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ğ’œ : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">Î±</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(hâ‚ : <span class="fn"><a href=".././LeanCamCombi/KruskalKatona.html#_private.LeanCamCombi.KruskalKatona.0.Finset.UW.UsefulCompression">Finset.UW.UsefulCompression</a> <span class="fn">U</span> <span class="fn">V</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hâ‚‚ : <span class="fn">âˆ€ â¦ƒ<span class="fn">Uâ‚ </span>Vâ‚ : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">Î±</span></span>â¦„, <span class="fn"><span class="fn"><a href=".././LeanCamCombi/KruskalKatona.html#_private.LeanCamCombi.KruskalKatona.0.Finset.UW.UsefulCompression">Finset.UW.UsefulCompression</a> <span class="fn">Uâ‚</span> <span class="fn">Vâ‚</span></span> â†’ <span class="fn"><span class="fn"><span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">Uâ‚</span></span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">U</span></span></span> â†’ <span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/SetFamily/Compression/UV.html#UW.IsCompressed">UW.IsCompressed</a> <span class="fn">Uâ‚</span> <span class="fn">Vâ‚</span> <span class="fn">ğ’œ</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href=".././Mathlib/Combinatorics/SetFamily/Shadow.html#Finset.shadow">Finset.shadow</a> (<span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/SetFamily/Compression/UV.html#UW.compression">UW.compression</a> <span class="fn">U</span> <span class="fn">V</span> <span class="fn">ğ’œ</span></span>)</span>)</span> <a href=".././Init/Prelude.html#LE.le">â‰¤</a> <span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href=".././Mathlib/Combinatorics/SetFamily/Shadow.html#Finset.shadow">Finset.shadow</a> <span class="fn">ğ’œ</span></span>)</span></span></div></div><p>Applying a good compression will decrease measure, keep cardinality, keep sizes and decrease
shadow. In particular, 'good' means it's useful, and every smaller compression won't make a
difference.</p></div></div><div class="decl" id="Finset.UW.isInitSeg_of_compressed"><div class="theorem"><div class="gh_link"><a href="https://github.com/YaelDillies/LeanCamCombi/blob/41ed909d6e8b5e6b618db6412ed63ba09eba61c3//LeanCamCombi/KruskalKatona.lean#L239-L258">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././LeanCamCombi/KruskalKatona.html#Finset.UW.isInitSeg_of_compressed"><span class="name">Finset</span>.<span class="name">UW</span>.<span class="name">isInitSeg_of_compressed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Î± : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Mathlib/Init/Order/Defs.html#LinearOrder">LinearOrder</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{â„¬ : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">Î±</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(hâ‚ : <span class="fn"><a href=".././Mathlib/Data/Finset/Slice.html#Set.Sized">Set.Sized</a> <span class="fn">r</span> <span class="fn">â†‘<span class="fn">â„¬</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hâ‚‚ : <span class="fn">âˆ€ (<span class="fn">U </span>V : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">Î±</span></span>), <span class="fn"><span class="fn"><a href=".././LeanCamCombi/KruskalKatona.html#_private.LeanCamCombi.KruskalKatona.0.Finset.UW.UsefulCompression">Finset.UW.UsefulCompression</a> <span class="fn">U</span> <span class="fn">V</span></span> â†’ <span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/SetFamily/Compression/UV.html#UW.IsCompressed">UW.IsCompressed</a> <span class="fn">U</span> <span class="fn">V</span> <span class="fn">â„¬</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/Colex.html#Finset.Wolex.IsInitSeg">Finset.Wolex.IsInitSeg</a> <span class="fn">â„¬</span> <span class="fn">r</span></span></div></div><p>If we're compressed by all useful compressions, then we're an initial segment. This is the other
key Kruskal-Katona part.</p></div></div><div class="decl" id="Finset.UW.familyMeasure_compression_lt_familyMeasure"><div class="theorem"><div class="gh_link"><a href="https://github.com/YaelDillies/LeanCamCombi/blob/41ed909d6e8b5e6b618db6412ed63ba09eba61c3//LeanCamCombi/KruskalKatona.lean#L273-L296">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././LeanCamCombi/KruskalKatona.html#Finset.UW.familyMeasure_compression_lt_familyMeasure"><span class="name">Finset</span>.<span class="name">UW</span>.<span class="name">familyMeasure_compression_lt_familyMeasure</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{hU : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset.Nonempty">Finset.Nonempty</a> <span class="fn">U</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{hV : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset.Nonempty">Finset.Nonempty</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href=".././Mathlib/Data/Finset/Lattice.html#Finset.max'">Finset.max'</a> <span class="fn">U</span> <span class="fn">hU</span></span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href=".././Mathlib/Data/Finset/Lattice.html#Finset.max'">Finset.max'</a> <span class="fn">V</span> <span class="fn">hV</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{ğ’œ : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/SetFamily/Compression/UV.html#UW.compression">UW.compression</a> <span class="fn">U</span> <span class="fn">V</span> <span class="fn">ğ’œ</span></span> <a href=".././Init/Core.html#Ne">â‰ </a> <span class="fn">ğ’œ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././LeanCamCombi/KruskalKatona.html#_private.LeanCamCombi.KruskalKatona.0.Finset.UW.familyMeasure">Finset.UW.familyMeasure</a> (<span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/SetFamily/Compression/UV.html#UW.compression">UW.compression</a> <span class="fn">U</span> <span class="fn">V</span> <span class="fn">ğ’œ</span></span>)</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href=".././LeanCamCombi/KruskalKatona.html#_private.LeanCamCombi.KruskalKatona.0.Finset.UW.familyMeasure">Finset.UW.familyMeasure</a> <span class="fn">ğ’œ</span></span></span></div></div><p>Applying a compression strictly decreases the measure. This helps show that "compress until we
can't any more" is a terminating process.</p></div></div><div class="decl" id="Finset.kruskal_katona"><div class="theorem"><div class="gh_link"><a href="https://github.com/YaelDillies/LeanCamCombi/blob/41ed909d6e8b5e6b618db6412ed63ba09eba61c3//LeanCamCombi/KruskalKatona.lean#L346-L354">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././LeanCamCombi/KruskalKatona.html#Finset.kruskal_katona"><span class="name">Finset</span>.<span class="name">kruskal_katona</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ğ’œ : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ğ’ : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hâ‚ : <span class="fn"><a href=".././Mathlib/Data/Finset/Slice.html#Set.Sized">Set.Sized</a> <span class="fn">r</span> <span class="fn">â†‘<span class="fn">ğ’œ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hâ‚‚ : <span class="fn"><span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">ğ’œ</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">ğ’</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hâ‚ƒ : <span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/Colex.html#Finset.Wolex.IsInitSeg">Finset.Wolex.IsInitSeg</a> <span class="fn">ğ’</span> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href=".././Mathlib/Combinatorics/SetFamily/Shadow.html#Finset.shadow">Finset.shadow</a> <span class="fn">ğ’</span></span>)</span> <a href=".././Init/Prelude.html#LE.le">â‰¤</a> <span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href=".././Mathlib/Combinatorics/SetFamily/Shadow.html#Finset.shadow">Finset.shadow</a> <span class="fn">ğ’œ</span></span>)</span></span></div></div><p>The Kruskal-Katona theorem. It says that given a set family <code>ğ’œ</code> consisting of <code>r</code>-sets, and <code>ğ’</code>
an initial segment of the wolex order of the same size, the shadow of <code>ğ’</code> is smaller than the shadow
of <code>ğ’œ</code>. In particular, this gives that the minimum shadow size is achieved by initial segments of
wolex.</p><p>Proof notes: Most of the work was done in Kruskal-Katona helper; it gives a <code>â„¬</code> which is fully
compressed, and so we know it's an initial segment, which by uniqueness is the same as <code>ğ’</code>.</p></div></div><div class="decl" id="Finset.strengthened_kk"><div class="theorem"><div class="gh_link"><a href="https://github.com/YaelDillies/LeanCamCombi/blob/41ed909d6e8b5e6b618db6412ed63ba09eba61c3//LeanCamCombi/KruskalKatona.lean#L358-L363">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././LeanCamCombi/KruskalKatona.html#Finset.strengthened_kk"><span class="name">Finset</span>.<span class="name">strengthened_kk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ğ’œ : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ğ’ : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hâ‚ : <span class="fn"><a href=".././Mathlib/Data/Finset/Slice.html#Set.Sized">Set.Sized</a> <span class="fn">r</span> <span class="fn">â†‘<span class="fn">ğ’œ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hâ‚‚ : <span class="fn"><span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">ğ’</span></span> <a href=".././Init/Prelude.html#LE.le">â‰¤</a> <span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">ğ’œ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hâ‚ƒ : <span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/Colex.html#Finset.Wolex.IsInitSeg">Finset.Wolex.IsInitSeg</a> <span class="fn">ğ’</span> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href=".././Mathlib/Combinatorics/SetFamily/Shadow.html#Finset.shadow">Finset.shadow</a> <span class="fn">ğ’</span></span>)</span> <a href=".././Init/Prelude.html#LE.le">â‰¤</a> <span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href=".././Mathlib/Combinatorics/SetFamily/Shadow.html#Finset.shadow">Finset.shadow</a> <span class="fn">ğ’œ</span></span>)</span></span></div></div><p>We can strengthen Kruskal-Katona slightly: note the middle and has been relaxed to a <code>â‰¤</code>.
This shows that the minimum possible shadow size is attained by initial segments.</p></div></div><div class="decl" id="Finset.iterated_kk"><div class="theorem"><div class="gh_link"><a href="https://github.com/YaelDillies/LeanCamCombi/blob/41ed909d6e8b5e6b618db6412ed63ba09eba61c3//LeanCamCombi/KruskalKatona.lean#L367-L372">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././LeanCamCombi/KruskalKatona.html#Finset.iterated_kk"><span class="name">Finset</span>.<span class="name">iterated_kk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ğ’œ : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ğ’ : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hâ‚ : <span class="fn"><a href=".././Mathlib/Data/Finset/Slice.html#Set.Sized">Set.Sized</a> <span class="fn">r</span> <span class="fn">â†‘<span class="fn">ğ’œ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hâ‚‚ : <span class="fn"><span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">ğ’</span></span> <a href=".././Init/Prelude.html#LE.le">â‰¤</a> <span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">ğ’œ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hâ‚ƒ : <span class="fn"><a href=".././LeanCamCombi/Mathlib/Combinatorics/Colex.html#Finset.Wolex.IsInitSeg">Finset.Wolex.IsInitSeg</a> <span class="fn">ğ’</span> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href=".././Mathlib/Logic/Function/Iterate.html#Nat.iterate"><span class="fn">Finset.shadow</span><a href=".././Mathlib/Logic/Function/Iterate.html#Nat.iterate">^[</a><span class="fn">k</span><a href=".././Mathlib/Logic/Function/Iterate.html#Nat.iterate">]</a></a> <span class="fn">ğ’</span></span>)</span> <a href=".././Init/Prelude.html#LE.le">â‰¤</a> <span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href=".././Mathlib/Logic/Function/Iterate.html#Nat.iterate"><span class="fn">Finset.shadow</span><a href=".././Mathlib/Logic/Function/Iterate.html#Nat.iterate">^[</a><span class="fn">k</span><a href=".././Mathlib/Logic/Function/Iterate.html#Nat.iterate">]</a></a> <span class="fn">ğ’œ</span></span>)</span></span></div></div><p>An iterated form of the Kruskal-Katona theorem. In particular, the minimum possible iterated
shadow size is attained by initial segments.</p></div></div><div class="decl" id="Finset.lovasz_form"><div class="theorem"><div class="gh_link"><a href="https://github.com/YaelDillies/LeanCamCombi/blob/41ed909d6e8b5e6b618db6412ed63ba09eba61c3//LeanCamCombi/KruskalKatona.lean#L379-L423">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././LeanCamCombi/KruskalKatona.html#Finset.lovasz_form"><span class="name">Finset</span>.<span class="name">lovasz_form</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ğ’œ : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hir : <span class="fn"><span class="fn">i</span> <a href=".././Init/Prelude.html#LE.le">â‰¤</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hrk : <span class="fn"><span class="fn">r</span> <a href=".././Init/Prelude.html#LE.le">â‰¤</a> <span class="fn">k</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hkn : <span class="fn"><span class="fn">k</span> <a href=".././Init/Prelude.html#LE.le">â‰¤</a> <span class="fn">n</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hâ‚ : <span class="fn"><a href=".././Mathlib/Data/Finset/Slice.html#Set.Sized">Set.Sized</a> <span class="fn">r</span> <span class="fn">â†‘<span class="fn">ğ’œ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hâ‚‚ : <span class="fn"><span class="fn"><a href=".././Mathlib/Data/Nat/Choose/Basic.html#Nat.choose">Nat.choose</a> <span class="fn">k</span> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#LE.le">â‰¤</a> <span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">ğ’œ</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Mathlib/Data/Nat/Choose/Basic.html#Nat.choose">Nat.choose</a> <span class="fn">k</span> (<span class="fn"><span class="fn">r</span> <a href=".././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">i</span></span>)</span> <a href=".././Init/Prelude.html#LE.le">â‰¤</a> <span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> (<span class="fn"><a href=".././Mathlib/Logic/Function/Iterate.html#Nat.iterate"><span class="fn">Finset.shadow</span><a href=".././Mathlib/Logic/Function/Iterate.html#Nat.iterate">^[</a><span class="fn">i</span><a href=".././Mathlib/Logic/Function/Iterate.html#Nat.iterate">]</a></a> <span class="fn">ğ’œ</span></span>)</span></span></div></div><p>A special case of Kruskal-Katona which is sometimes easier to work with.
If <code>|ğ’œ| â‰¥ k choose r</code>, (and everything in <code>ğ’œ</code> has size <code>r</code>) then the initial segment we compare to
is just all the subsets of <code>{0, ..., k - 1}</code> of size <code>r</code>. The <code>i</code>-th iterated shadow of this is all
the subsets of <code>{0, ..., k - 1}</code> of size <code>r - i</code>, so the <code>i</code>-th iterated shadow of <code>ğ’œ</code> has at least
<code>k.choose (r - i)</code> elements.</p></div></div><div class="decl" id="Finset.EKR"><div class="theorem"><div class="gh_link"><a href="https://github.com/YaelDillies/LeanCamCombi/blob/41ed909d6e8b5e6b618db6412ed63ba09eba61c3//LeanCamCombi/KruskalKatona.lean#L429-L477">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././LeanCamCombi/KruskalKatona.html#Finset.EKR"><span class="name">Finset</span>.<span class="name">EKR</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ğ’œ : <span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> (<span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <a href=".././Init/Prelude.html#Nat">â„•</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(hğ’œ : <span class="fn"><a href=".././Mathlib/Combinatorics/SetFamily/Intersecting.html#Set.Intersecting">Set.Intersecting</a> <span class="fn">â†‘<span class="fn">ğ’œ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hâ‚‚ : <span class="fn"><a href=".././Mathlib/Data/Finset/Slice.html#Set.Sized">Set.Sized</a> <span class="fn">r</span> <span class="fn">â†‘<span class="fn">ğ’œ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hâ‚ƒ : <span class="fn"><span class="fn">r</span> <a href=".././Init/Prelude.html#LE.le">â‰¤</a> <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">2</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Mathlib/Data/Finset/Card.html#Finset.card">Finset.card</a> <span class="fn">ğ’œ</span></span> <a href=".././Init/Prelude.html#LE.le">â‰¤</a> <span class="fn"><a href=".././Mathlib/Data/Nat/Choose/Basic.html#Nat.choose">Nat.choose</a> (<span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></span>) (<span class="fn"><span class="fn">r</span> <a href=".././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></span>)</span></span></div></div><p>The <strong>ErdÅ‘sâ€“Koâ€“Rado lemma</strong>: The maximum size of an intersecting family in <code>Î±</code> where all sets
have size <code>r</code> is bounded by <code>(card Î± - 1).choose (r - 1)</code>. This bound is sharp.</p></div></div></main>
<nav class="nav"><iframe src=".././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>