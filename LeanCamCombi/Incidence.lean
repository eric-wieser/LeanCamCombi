/-
Copyright (c) 2022 Alex J. Best, Ya√´l Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Alex J. Best, Ya√´l Dillies
-/
import Mathlib.Algebra.Algebra.Basic
import Mathlib.Algebra.BigOperators.Ring
import Mathlib.Algebra.Module.BigOperators
import Mathlib.GroupTheory.GroupAction.Basic
import Mathlib.GroupTheory.GroupAction.Pi
import Mathlib.Data.Finset.LocallyFinite
import LeanCamCombi.Mathlib.GroupTheory.GroupAction.Defs

/-!
# Incidence algebras

Given a locally finite order `Œ±` the incidence algebra over `Œ±` is the type of functions from
non-empty intervals of `Œ±` to some algebraic codomain.
This algebra has a natural multiplication operation whereby the product of two such functions
is defined on an interval by summing over all divisions into two subintervals the product of the
values of the original pair of functions.
This structure allows us to interpret many natural invariants of the intervals (such as their
cardinality) as elements of the incidence algebra. For instance the cardinality function, viewed as
an element of the incidence algebra, is simply the square of the function that takes constant value
one on all intervals. This constant function is called the zeta function, after
its connection with the Riemann zeta function.
The incidence algebra is a good setting for proving many inclusion-exclusion type principles, these
go under the name M√∂bius inversion, and are essentially due to the fact that the zeta function has
a multiplicative inverse in the incidence algebra, an inductively definable function called the
M√∂bius function that generalizes the M√∂bius function in number theory.

## References

- Aigner - Combinatorial Theory, Chapter IV
- Jacobson - Basic Algebra I, 8.6
- Rota - On the foundations of Combinatorial Theory
- Spiegel, O'Donnell - Incidence Algebras
- Kung, Rota, Yan - Combinatorics: The Rota Way, Chapter 3

## TODOs

Here are some additions to this file that could be made in the future:
- Generalize the construction of `mu` to invert any element of the incidence algebra `f` which has
  `f x x` a unit for all `x`.
- Give formulae for higher powers of zeta.
- A formula for the m√∂bius function on a pi type similar to the one for products
- More examples / applications to different posets.
- Connection with Galois insertions
- Finsum version of M√∂bius inversion that holds even when an order doesn't have top/bot?
- Connect this theory to (infinite) matrices, giving maps of the incidence algebra to matrix rings
- Connect to the more advanced theory of arithmetic functions, and Dirichlet convolution.
-/

-- TODO: Rename `prod.Icc_eq` to `finset.Icc_prod_eq` to match `set.Icc_prod_eq`
open Finset

open scoped BigOperators

namespace Finset

section

variable {Œ± Œ≤ : Type*} [Preorder Œ±] [Preorder Œ≤] [LocallyFiniteOrder Œ±] [LocallyFiniteOrder Œ≤]
  [DecidableRel ((¬∑ ‚â§ ¬∑) : Œ± ‚Üí Œ± ‚Üí Prop)] [DecidableRel ((¬∑ ‚â§ ¬∑) : Œ≤ ‚Üí Œ≤ ‚Üí Prop)]

lemma prod_Icc (a b : Œ± √ó Œ≤) : Icc a b = (Icc a.fst b.fst).product (Icc a.snd b.snd) := by
  rw [Prod.Icc_eq]; rfl

end

section Pre

variable {Œ± : Type*} [Preorder Œ±] [LocallyFiniteOrder Œ±] {a b c : Œ±}

lemma card_Icc_lt_card_Icc_left (hab : a ‚â§ b) (h : c < b) : (Icc a c).card < (Icc a b).card :=
  card_lt_card (Icc_ssubset_Icc_right hab le_rfl h)

lemma card_Icc_lt_card_Icc_right (hab : a ‚â§ b) (h : a < c) : (Icc c b).card < (Icc a b).card :=
  @card_Icc_lt_card_Icc_left Œ±·µí·µà _ _ _ _ _ hab h

end Pre

variable {Œ± Œ≤ : Type*} [PartialOrder Œ±] [CommMonoid Œ≤] {f : Œ± ‚Üí Œ≤} {a b : Œ±}

section LocallyFiniteOrder

variable [LocallyFiniteOrder Œ±]

@[to_additive]
lemma mul_prod_Ico (h : a ‚â§ b) : f b * ‚àè x in Ico a b, f x = ‚àè x in Icc a b, f x := by
  rw [Icc_eq_cons_Ico h, prod_cons]

@[to_additive]
lemma mul_prod_Ioc (h : a ‚â§ b) : f a * ‚àè x in Ioc a b, f x = ‚àè x in Icc a b, f x := by
  rw [Icc_eq_cons_Ioc h, prod_cons]

end LocallyFiniteOrder

section LocallyFiniteOrderTop

variable [LocallyFiniteOrderTop Œ±]

@[to_additive]
lemma mul_prod_Ioi (a : Œ±) : f a * ‚àè x in Ioi a, f x = ‚àè x in Ici a, f x := by
  rw [Ici_eq_cons_Ioi, prod_cons]

end LocallyFiniteOrderTop

section LocallyFiniteOrderBot

variable [LocallyFiniteOrderBot Œ±]

@[to_additive]
lemma mul_prod_Iio (a : Œ±) : f a * ‚àè x in Iio a, f x = ‚àè x in Iic a, f x := by
  rw [Iic_eq_cons_Iio, prod_cons]

end LocallyFiniteOrderBot

end Finset

open Finset OrderDual
open scoped BigOperators

variable {ùïÑ F ùïú ùïù ùïû Œ± Œ≤ : Type*}

/-- The `ùïú`-incidence algebra over `Œ±`. -/
structure IncidenceAlgebra (ùïú Œ± : Type*) [Zero ùïú] [LE Œ±] where
  toFun : Œ± ‚Üí Œ± ‚Üí ùïú
  eq_zero_of_not_le' ‚¶Éa b : Œ±‚¶Ñ : ¬¨a ‚â§ b ‚Üí toFun a b = 0

namespace IncidenceAlgebra

section Zero

variable [Zero ùïú] [LE Œ±] {a b : Œ±}

instance funLike : FunLike (IncidenceAlgebra ùïú Œ±) Œ± fun _ => Œ± ‚Üí ùïú :=
  ‚ü®toFun, fun f g h => by cases f; cases g; congr‚ü©

lemma apply_eq_zero_of_not_le (h : ¬¨a ‚â§ b) (f : IncidenceAlgebra ùïú Œ±) : f a b = 0 :=
  eq_zero_of_not_le' _ h

lemma le_of_ne_zero {f : IncidenceAlgebra ùïú Œ±} : f a b ‚â† 0 ‚Üí a ‚â§ b :=
  not_imp_comm.1 fun h => apply_eq_zero_of_not_le h _

-- completely uninteresting lemmas about coercion to function, that all homs need
section Coes

-- Fallback `has_coe_toFun` instance to help the elaborator
instance : CoeFun (IncidenceAlgebra ùïú Œ±) fun _ => Œ± ‚Üí Œ± ‚Üí ùïú :=
  FunLike.hasCoeToFun

-- this must come after the coe_toFun definitions
initialize_simps_projections IncidenceAlgebra (toFun ‚Üí apply)

@[simp]
lemma toFun_eq_coe (f : IncidenceAlgebra ùïú Œ±) : f.toFun = f :=
  rfl

@[simp, norm_cast]
lemma coe_mk (f : Œ± ‚Üí Œ± ‚Üí ùïú) (h) : (mk f h : Œ± ‚Üí Œ± ‚Üí ùïú) = f :=
  rfl

protected lemma congr_fun {f g : IncidenceAlgebra ùïú Œ±} (h : f = g) (a b : Œ±) : f a b = g a b :=
  congr_arg (fun f : IncidenceAlgebra ùïú Œ± => f a b) h

protected lemma congr_arg (f : IncidenceAlgebra ùïú Œ±) {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ : Œ±} (ha : a‚ÇÅ = a‚ÇÇ)
    (hb : b‚ÇÅ = b‚ÇÇ) : f a‚ÇÅ b‚ÇÅ = f a‚ÇÇ b‚ÇÇ :=
  congr_arg‚ÇÇ f ha hb

@[simp]
lemma coe_inj {f g : IncidenceAlgebra ùïú Œ±} : (f : Œ± ‚Üí Œ± ‚Üí ùïú) = g ‚Üî f = g :=
  FunLike.coe_injective.eq_iff

@[ext]
lemma ext ‚¶Éf g : IncidenceAlgebra ùïú Œ±‚¶Ñ (h : ‚àÄ (a b) (hab : a ‚â§ b), f a b = g a b) : f = g := by
  refine' FunLike.coe_injective (funext‚ÇÇ fun a b => _)
  by_cases hab : a ‚â§ b
  ¬∑ exact h _ _ hab
  ¬∑ rw [apply_eq_zero_of_not_le hab, apply_eq_zero_of_not_le hab]

lemma ext_iff {f g : IncidenceAlgebra ùïú Œ±} : f = g ‚Üî ‚àÄ a b, f a b = g a b :=
  ‚ü®IncidenceAlgebra.congr_fun, fun h => ext fun a b _ => h _ _‚ü©

@[simp]
lemma mk_coe (f : IncidenceAlgebra ùïú Œ±) (h) : mk f h = f :=
  ext fun _ _ _ => rfl

end Coes

/-! ### Additive and multiplicative structure -/

variable {ùïú Œ±}

instance : Zero (IncidenceAlgebra ùïú Œ±) :=
  ‚ü®‚ü®fun _ _ => 0, fun _ _ _ => rfl‚ü©‚ü©

instance : Inhabited (IncidenceAlgebra ùïú Œ±) :=
  ‚ü®0‚ü©

@[simp, norm_cast]
lemma coe_zero : ‚áë(0 : IncidenceAlgebra ùïú Œ±) = 0 :=
  rfl

lemma zero_apply (a b : Œ±) : (0 : IncidenceAlgebra ùïú Œ±) a b = 0 :=
  rfl

end Zero

section Add

variable [AddZeroClass ùïú] [LE Œ±]

instance : Add (IncidenceAlgebra ùïú Œ±) :=
  ‚ü®fun f g => ‚ü®f + g, fun a b h => by simp_rw [Pi.add_apply, apply_eq_zero_of_not_le h, zero_add]‚ü©‚ü©

@[simp, norm_cast]
lemma coe_add (f g : IncidenceAlgebra ùïú Œ±) : ‚áë(f + g) = f + g :=
  rfl

lemma add_apply (f g : IncidenceAlgebra ùïú Œ±) (a b : Œ±) : (f + g) a b = f a b + g a b :=
  rfl

end Add

section Smul

variable {M : Type*} [Zero ùïú] [LE Œ±] [SMulZeroClass M ùïú]

instance smulZeroClassRight : SMulZeroClass M (IncidenceAlgebra ùïú Œ±)
    where
  smul c f :=
    ‚ü®c ‚Ä¢ f, fun a b hab => by simp_rw [Pi.smul_apply, apply_eq_zero_of_not_le hab, smul_zero]‚ü©
  smul_zero c := by ext; simp

@[simp, norm_cast]
lemma coe_smul' (c : M) (f : IncidenceAlgebra ùïú Œ±) : ‚áë(c ‚Ä¢ f) = c ‚Ä¢ f :=
  rfl

lemma smul_apply' (c : M) (f : IncidenceAlgebra ùïú Œ±) (a b : Œ±) : (c ‚Ä¢ f) a b = c ‚Ä¢ f a b :=
  rfl

end Smul

instance [AddMonoid ùïú] [LE Œ±] : AddMonoid (IncidenceAlgebra ùïú Œ±) :=
  FunLike.coe_injective.AddMonoid _ coe_zero coe_add fun _ _ => rfl

instance [AddCommMonoid ùïú] [LE Œ±] : AddCommMonoid (IncidenceAlgebra ùïú Œ±) :=
  FunLike.coe_injective.AddCommMonoid _ coe_zero coe_add fun _ _ => rfl

section AddGroup

variable [AddGroup ùïú] [LE Œ±]

instance : Neg (IncidenceAlgebra ùïú Œ±) :=
  ‚ü®fun f => ‚ü®-f, fun a b h => by simp_rw [Pi.neg_apply, apply_eq_zero_of_not_le h, neg_zero]‚ü©‚ü©

instance : Sub (IncidenceAlgebra ùïú Œ±) :=
  ‚ü®fun f g => ‚ü®f - g, fun a b h => by simp_rw [Pi.sub_apply, apply_eq_zero_of_not_le h, sub_zero]‚ü©‚ü©

@[simp, norm_cast]
lemma coe_neg (f : IncidenceAlgebra ùïú Œ±) : ‚áë(-f) = -f :=
  rfl

@[simp, norm_cast]
lemma coe_sub (f g : IncidenceAlgebra ùïú Œ±) : ‚áë(f - g) = f - g :=
  rfl

lemma neg_apply (f : IncidenceAlgebra ùïú Œ±) (a b : Œ±) : (-f) a b = -f a b :=
  rfl

lemma sub_apply (f g : IncidenceAlgebra ùïú Œ±) (a b : Œ±) : (f - g) a b = f a b - g a b :=
  rfl

instance : AddGroup (IncidenceAlgebra ùïú Œ±) :=
  FunLike.coe_injective.AddGroup _ coe_zero coe_add coe_neg coe_sub (fun _ _ => rfl) fun _ _ => rfl

end AddGroup

instance [AddCommGroup ùïú] [LE Œ±] : AddCommGroup (IncidenceAlgebra ùïú Œ±) :=
  FunLike.coe_injective.AddCommGroup _ coe_zero coe_add coe_neg coe_sub (fun _ _ => rfl) fun _ _ =>
    rfl

section One

variable [Preorder Œ±] [DecidableEq Œ±] [Zero ùïú] [One ùïú]

instance : One (IncidenceAlgebra ùïú Œ±) :=
  ‚ü®‚ü®fun a b => if a = b then 1 else 0, fun a b h => ite_eq_right_iff.2 fun H => (h H.le).elim‚ü©‚ü©

@[simp]
lemma one_apply (a b : Œ±) : (1 : IncidenceAlgebra ùïú Œ±) a b = if a = b then 1 else 0 :=
  rfl

end One

section Mul

variable [Preorder Œ±] [LocallyFiniteOrder Œ±] [AddCommMonoid ùïú] [Mul ùïú]

instance : Mul (IncidenceAlgebra ùïú Œ±) :=
  ‚ü®fun f g =>
    ‚ü®fun a b => ‚àë x in Icc a b, f a x * g x b, fun a b h => by rw [Icc_eq_empty h, sum_empty]‚ü©‚ü©

@[simp]
lemma mul_apply (f g : IncidenceAlgebra ùïú Œ±) (a b : Œ±) :
    (f * g) a b = ‚àë x in Icc a b, f a x * g x b :=
  rfl

end Mul

instance [Preorder Œ±] [LocallyFiniteOrder Œ±] [NonUnitalNonAssocSemiring ùïú] :
    NonUnitalNonAssocSemiring (IncidenceAlgebra ùïú Œ±) :=
  { IncidenceAlgebra.addCommMonoid with
    mul := (¬∑ * ¬∑)
    zero := 0
    zero_mul := fun f => by ext; exact sum_eq_zero fun x _ => MulZeroClass.zero_mul _
    mul_zero := fun f => by ext; exact sum_eq_zero fun x _ => MulZeroClass.mul_zero _
    left_distrib := fun f g h => by ext;
      exact Eq.trans (sum_congr rfl fun x _ => left_distrib _ _ _) sum_add_distrib
    right_distrib := fun f g h => by ext;
      exact Eq.trans (sum_congr rfl fun x _ => right_distrib _ _ _) sum_add_distrib }

instance [Preorder Œ±] [LocallyFiniteOrder Œ±] [DecidableEq Œ±] [NonAssocSemiring ùïú] :
    NonAssocSemiring (IncidenceAlgebra ùïú Œ±) :=
  {
    IncidenceAlgebra.nonUnitalNonAssocSemiring with
    mul := (¬∑ * ¬∑)
    zero := 0
    one := 1
    one_mul := fun f => by
      ext a b
      simp_rw [mul_apply, one_apply, sum_boole_mul]
      exact ite_eq_left_iff.2 (not_imp_comm.1 fun h => left_mem_Icc.2 <| le_of_ne_zero <| Ne.symm h)
    mul_one := fun f => by
      ext a b
      simp_rw [mul_apply, one_apply, eq_comm, sum_mul_boole]
      convert
        (ite_eq_left_iff.2 <|
            not_imp_comm.1 fun h => right_mem_Icc.2 <| le_of_ne_zero <| Ne.symm h).symm }

instance [Preorder Œ±] [LocallyFiniteOrder Œ±] [DecidableEq Œ±] [Semiring ùïú] :
    Semiring (IncidenceAlgebra ùïú Œ±) :=
  { IncidenceAlgebra.nonAssocSemiring with
    mul := (¬∑ * ¬∑)
    mul_assoc := fun f g h => by
      ext a b
      simp only [mul_apply, sum_mul, mul_sum]
      rw [sum_sigma', sum_sigma']
      dsimp
      apply sum_bij fun (x : Œ£ i : Œ±, Œ±) hx => (Sigma.mk x.snd x.fst : Œ£ i : Œ±, Œ±)
      ¬∑ rintro c hc
        simp only [mem_sigma, mem_Icc] at hc
        simp only [mem_sigma, mem_Icc]
        exact ‚ü®‚ü®hc.2.1, hc.2.2.trans hc.1.2‚ü©, hc.2.2, hc.1.2‚ü©
      ¬∑ rintro c hc
        simp only [mul_assoc]
      ¬∑ rintro ‚ü®c‚ÇÅ, c‚ÇÇ‚ü© ‚ü®d‚ÇÅ, d‚ÇÇ‚ü© hc hd ‚ü®‚ü©
        rfl
      ¬∑ rintro c hc
        simp only [exists_prop, Sigma.exists, mem_sigma, heq_iff_eq, Sigma.mk.inj_iff, mem_Icc] at *
        exact ‚ü®c.2, c.1, ‚ü®‚ü®hc.1.1.trans hc.2.1, hc.2.2‚ü©, hc.1.1, hc.2.1‚ü©, c.eta.symm‚ü©
    one := 1
    zero := 0 }

instance [Preorder Œ±] [LocallyFiniteOrder Œ±] [DecidableEq Œ±] [Ring ùïú] :
    Ring (IncidenceAlgebra ùïú Œ±) :=
  { IncidenceAlgebra.semiring, IncidenceAlgebra.addGroup with }

/-! ### Scalar multiplication between incidence algebras -/

section Smul

variable [Preorder Œ±] [LocallyFiniteOrder Œ±] [AddCommMonoid ùïú] [AddCommMonoid ùïù] [SMul ùïú ùïù]

instance : SMul (IncidenceAlgebra ùïú Œ±) (IncidenceAlgebra ùïù Œ±) :=
  ‚ü®fun f g =>
    ‚ü®fun a b => ‚àë x in Icc a b, f a x ‚Ä¢ g x b, fun a b h => by rw [Icc_eq_empty h, sum_empty]‚ü©‚ü©

@[simp]
lemma smul_apply (f : IncidenceAlgebra ùïú Œ±) (g : IncidenceAlgebra ùïù Œ±) (a b : Œ±) :
    (f ‚Ä¢ g) a b = ‚àë x in Icc a b, f a x ‚Ä¢ g x b :=
  rfl

end Smul

instance [Preorder Œ±] [LocallyFiniteOrder Œ±] [AddCommMonoid ùïú] [Monoid ùïú] [Semiring ùïù]
    [AddCommMonoid ùïû] [SMul ùïú ùïù] [Module ùïù ùïû] [DistribMulAction ùïú ùïû] [IsScalarTower ùïú ùïù ùïû] :
    IsScalarTower (IncidenceAlgebra ùïú Œ±) (IncidenceAlgebra ùïù Œ±) (IncidenceAlgebra ùïû Œ±) :=
  ‚ü®fun f g h => by
    ext a b
    simp only [smul_apply, sum_smul, smul_sum]
    rw [sum_sigma', sum_sigma']
    dsimp
    apply sum_bij fun (x : Œ£ i : Œ±, Œ±) hx => (Sigma.mk x.snd x.fst : Œ£ i : Œ±, Œ±)
    ¬∑ rintro c hc
      simp only [mem_sigma, mem_Icc] at hc
      simp only [mem_sigma, mem_Icc]
      exact ‚ü®‚ü®hc.2.1, hc.2.2.trans hc.1.2‚ü©, hc.2.2, hc.1.2‚ü©
    ¬∑ rintro c hc
      simp only [smul_assoc]
    ¬∑ rintro ‚ü®c‚ÇÅ, c‚ÇÇ‚ü© ‚ü®d‚ÇÅ, d‚ÇÇ‚ü© hc hd ‚ü®‚ü©
      rfl
    ¬∑ rintro c hc
      simp only [exists_prop, Sigma.exists, mem_sigma, heq_iff_eq, Sigma.mk.inj_iff, mem_Icc] at *
      exact ‚ü®c.2, c.1, ‚ü®‚ü®hc.1.1.trans hc.2.1, hc.2.2‚ü©, hc.1.1, hc.2.1‚ü©, c.eta.symm‚ü©‚ü©

instance [Preorder Œ±] [LocallyFiniteOrder Œ±] [DecidableEq Œ±] [Semiring ùïú] [Semiring ùïù]
    [Module ùïú ùïù] : Module (IncidenceAlgebra ùïú Œ±) (IncidenceAlgebra ùïù Œ±)
    where
  smul := (¬∑ ‚Ä¢ ¬∑)
  one_smul f := by
    ext a b
    simp [ite_smul, hab]
  mul_smul f g h := by
    convert smul_assoc _ _ _
    ext a b
    rfl
    infer_instance
  smul_add f g h := by ext; exact Eq.trans (sum_congr rfl fun x _ => smul_add _ _ _) sum_add_distrib
  add_smul f g h := by ext; exact Eq.trans (sum_congr rfl fun x _ => add_smul _ _ _) sum_add_distrib
  zero_smul f := by ext; exact sum_eq_zero fun x _ => zero_smul _ _
  smul_zero f := by ext; exact sum_eq_zero fun x _ => smul_zero _

instance smulWithZeroRight [Zero ùïú] [Zero ùïù] [SMulWithZero ùïú ùïù] [LE Œ±] :
    SMulWithZero ùïú (IncidenceAlgebra ùïù Œ±) :=
  Function.Injective.smulWithZero ‚ü®(coeFn : IncidenceAlgebra ùïù Œ± ‚Üí Œ± ‚Üí Œ± ‚Üí ùïù), coe_zero‚ü©
    FunLike.coe_injective coe_smul'

instance moduleRight [Preorder Œ±] [Semiring ùïú] [AddCommMonoid ùïù] [Module ùïú ùïù] :
    Module ùïú (IncidenceAlgebra ùïù Œ±) :=
  Function.Injective.module _ ‚ü®(coeFn : IncidenceAlgebra ùïù Œ± ‚Üí Œ± ‚Üí Œ± ‚Üí ùïù), coe_zero, coe_add‚ü©
    FunLike.coe_injective coe_smul'

instance algebraRight [PartialOrder Œ±] [LocallyFiniteOrder Œ±] [DecidableEq Œ±] [CommSemiring ùïú]
    [CommSemiring ùïù] [Algebra ùïú ùïù] : Algebra ùïú (IncidenceAlgebra ùïù Œ±)
    where
  smul := (¬∑ ‚Ä¢ ¬∑)
  toFun c := algebraMap ùïú ùïù c ‚Ä¢ 1
  map_one' := by
    ext
    simp only [mul_boole, one_apply, Algebra.id.smul_eq_mul, smul_apply', map_one]
  map_mul' c d := by
    ext
    obtain rfl | h := eq_or_ne a b
    ¬∑ simp only [smul_boole, one_apply, Algebra.id.smul_eq_mul, mul_apply, Algebra.mul_smul_comm,
        boole_smul, smul_apply', ‚Üê ite_and, algebraMap_smul, map_mul, Algebra.smul_mul_assoc,
        if_pos rfl, eq_comm, and_self_iff, Icc_self]
      simp only [mul_one, if_true, Algebra.mul_smul_comm, smul_boole, MulZeroClass.zero_mul,
        ite_mul, sum_ite_eq, Algebra.smul_mul_assoc, mem_singleton]
      rw [Algebra.algebraMap_eq_smul_one, Algebra.algebraMap_eq_smul_one]
      simp only [mul_one, Algebra.mul_smul_comm, Algebra.smul_mul_assoc, if_pos rfl]
    ¬∑ simp only [true_and_iff, if_t_t, le_refl, one_apply, mul_one, Algebra.id.smul_eq_mul,
        mul_apply, Algebra.mul_smul_comm, smul_boole, MulZeroClass.zero_mul, smul_apply',
        algebraMap_smul, ‚Üê ite_and, ite_mul, mul_ite, map_mul, mem_Icc, sum_ite_eq,
        MulZeroClass.mul_zero, smul_zero, Algebra.smul_mul_assoc, if_pos rfl, if_neg h]
      refine' (sum_eq_zero fun x _ => _).symm
      exact if_neg fun hx => h <| hx.2.trans hx.1
  map_zero' := by rw [map_zero, zero_smul]
  map_add' c d := by rw [map_add, add_smul]
  commutes' c f := by
    classical
    ext
    simp [if_pos hab]
  smul_def' c f := by
    classical
    ext
    simp [if_pos hab]

/-! ### The Lambda function -/

section Lambda

variable (ùïú) [Zero ùïú] [One ùïú] [Preorder Œ±] [@DecidableRel Œ± (¬∑ ‚©ø ¬∑)]

/-- The lambda function of the incidence algebra is the function that assigns `1` to every nonempty
interval of cardinality one or two. -/
def lambda : IncidenceAlgebra ùïú Œ± :=
  ‚ü®fun a b => if a ‚©ø b then 1 else 0, fun a b h => if_neg fun hh => h hh.le‚ü©

variable {ùïú}

-- TODO: Can't this be autogenerated?
@[simp] lemma lambda_apply (a b : Œ±) : lambda ùïú a b = if a ‚©ø b then 1 else 0 := rfl

end Lambda

/-! ### The Zeta and M√∂bius functions -/

section Zeta

variable (ùïú) [Zero ùïú] [One ùïú] [LE Œ±] [@DecidableRel Œ± (¬∑ ‚â§ ¬∑)] {a b : Œ±}

/-- The zeta function of the incidence algebra is the function that assigns 1 to every nonempty
interval, convolution with this function sums functions over intervals. -/
def zeta : IncidenceAlgebra ùïú Œ± :=
  ‚ü®fun a b => if a ‚â§ b then 1 else 0, fun a b h => if_neg h‚ü©

variable {ùïú}

@[simp]
lemma zeta_apply (a b : Œ±) : zeta ùïú a b = if a ‚â§ b then 1 else 0 := rfl

lemma zeta_of_le (h : a ‚â§ b) : zeta ùïú a b = 1 := if_pos h

end Zeta

lemma zeta_mul_zeta [Semiring ùïú] [Preorder Œ±] [LocallyFiniteOrder Œ±] [@DecidableRel Œ± (¬∑ ‚â§ ¬∑)]
    (a b : Œ±) : (zeta ùïú * zeta ùïú) a b = (Icc a b).card := by
  rw [mul_apply, card_eq_sum_ones, Nat.cast_sum, Nat.cast_one]
  refine' sum_congr rfl fun x hx => _
  rw [mem_Icc] at hx
  rw [zeta_of_le hx.1, zeta_of_le hx.2, one_mul]

lemma zeta_mul_kappa [Semiring ùïú] [Preorder Œ±] [LocallyFiniteOrder Œ±] [@DecidableRel Œ± (¬∑ ‚â§ ¬∑)]
    (a b : Œ±) : (zeta ùïú * zeta ùïú) a b = (Icc a b).card := by
  rw [mul_apply, card_eq_sum_ones, Nat.cast_sum, Nat.cast_one]
  refine' sum_congr rfl fun x hx => _
  rw [mem_Icc] at hx
  rw [zeta_of_le hx.1, zeta_of_le hx.2, one_mul]

section Mu

variable (ùïú) [AddCommGroup ùïú] [One ùïú] [Preorder Œ±] [LocallyFiniteOrder Œ±] [DecidableEq Œ±]

/-- The M√∂bius function of the incidence algebra as a bare function defined recursively. -/
def muAux (a : Œ±) : Œ± ‚Üí ùïú
  | b =>
    if h : a = b then 1
    else
      -‚àë x in (Ico a b).attach,
          let h := mem_Ico.1 x.2
          have : (Icc a x).card < (Icc a b).card :=
            card_lt_card (Icc_ssubset_Icc_right (h.1.trans h.2.le) le_rfl h.2)
          mu_aux x
termination_by' ‚ü®_, measure_wf fun b => (Icc a b).card‚ü©

lemma muAux_apply (a b : Œ±) :
    muAux ùïú a b = if a = b then 1 else -‚àë x in (Ico a b).attach, muAux ùïú a x := by
  convert has_well_founded.wf.fix_eq _ _; rfl

/-- The M√∂bius function which inverts `zeta` as an element of the incidence algebra. -/
def mu : IncidenceAlgebra ùïú Œ± :=
  ‚ü®muAux ùïú, fun a b =>
    not_imp_comm.1 fun h => by
      rw [mu_aux_apply] at h
      split_ifs at h  with hab hab
      ¬∑ exact hab.le
      ¬∑ rw [neg_eq_zero] at h
        obtain ‚ü®‚ü®x, hx‚ü©, -‚ü© := exists_ne_zero_of_sum_ne_zero h
        exact (nonempty_Ico.1 ‚ü®x, hx‚ü©).le‚ü©

variable {ùïú}

lemma mu_apply (a b : Œ±) : mu ùïú a b = if a = b then 1 else -‚àë x in Ico a b, mu ùïú a x := by
  rw [mu, coe_mk, mu_aux_apply, sum_attach]

lemma mu_apply_of_eq {a b : Œ±} (h : a = b) : mu ùïú a b = 1 := by rw [mu_apply, if_pos h]

@[simp]
lemma mu_apply_self (a : Œ±) : mu ùïú a a = 1 :=
  mu_apply_of_eq rfl

lemma mu_apply_of_ne {a b : Œ±} (h : a ‚â† b) : mu ùïú a b = -‚àë x in Ico a b, mu ùïú a x := by
  rw [mu_apply, if_neg h]

end Mu

section MuSpec

variable {ùïú Œ±} [AddCommGroup ùïú] [One ùïú] [PartialOrder Œ±] [LocallyFiniteOrder Œ±] [DecidableEq Œ±]

-- we need partial order for this
lemma mu_spec_of_ne_right {a b : Œ±} (h : a ‚â† b) : ‚àë x in Icc a b, mu ùïú a x = 0 := by
  have : mu ùïú a b = _ := mu_apply_of_ne h by_cases hab : a ‚â§ b
  ¬∑ rw [‚Üê add_sum_Ico hab, this, neg_add_self]
  ¬∑ have : ‚àÄ x ‚àà Icc a b, ¬¨a ‚â§ x := by intro x hx hn; apply hab; rw [mem_Icc] at hx ;
      exact le_trans hn hx.2
    conv in mu _ _ _ => rw [apply_eq_zero_of_not_le (this x H)]
    exact sum_const_zero

end MuSpec

section Mu'

variable (ùïú) [AddCommGroup ùïú] [One ùïú] [Preorder Œ±] [LocallyFiniteOrder Œ±] [DecidableEq Œ±]

-- this is the reversed definition of mu, which is equal to mu but easiest to prove equal
-- by showing that zeta * mu = 1 and mu' * zeta = 1
-- therefore mu' should be an implementation detail and not used
private def mu'_aux (b : Œ±) : Œ± ‚Üí ùïú
  | a =>
    if h : a = b then 1
    else
      -‚àë x in (Ioc a b).attach,
          let h := mem_Ioc.1 x.2
          have : (Icc (‚Üëx) b).card < (Icc a b).card :=
            card_lt_card (Icc_ssubset_Icc_left (h.1.le.trans h.2) h.1 le_rfl)
          mu'_aux x
termination_by' ‚ü®_, measure_wf fun a => (Icc a b).card‚ü©

private lemma mu'_aux_apply (a b : Œ±) :
    mu'Aux ùïú b a = if a = b then 1 else -‚àë x in (Ioc a b).attach, mu'Aux ùïú b x := by
  convert has_well_founded.wf.fix_eq _ _; rfl

private def mu' : IncidenceAlgebra ùïú Œ± :=
  ‚ü®fun a b => mu'Aux ùïú b a, fun a b =>
    not_imp_comm.1 fun h => by
      rw [mu'_aux_apply] at h
      split_ifs at h  with hab hab
      ¬∑ exact hab.le
      ¬∑ rw [neg_eq_zero] at h
        obtain ‚ü®‚ü®x, hx‚ü©, -‚ü© := exists_ne_zero_of_sum_ne_zero h
        exact (nonempty_Ioc.1 ‚ü®x, hx‚ü©).le‚ü©

variable {ùïú}

lemma mu'_apply (a b : Œ±) : mu' ùïú a b = if a = b then 1 else -‚àë x in Ioc a b, mu' ùïú x b := by
  rw [mu', coe_mk, mu'_aux_apply, sum_attach]

lemma mu'_apply_of_ne {a b : Œ±} (h : a ‚â† b) : mu' ùïú a b = -‚àë x in Ioc a b, mu' ùïú x b := by
  rw [mu'_apply, if_neg h]

lemma mu'_apply_of_eq {a b : Œ±} (h : a = b) : mu' ùïú a b = 1 := by rw [mu'_apply, if_pos h]

@[simp]
lemma mu'_apply_self (a : Œ±) : mu' ùïú a a = 1 :=
  mu'_apply_of_eq rfl

end Mu'

section Mu'Spec

-- we need partial order for this
variable [AddCommGroup ùïú] [One ùïú] [PartialOrder Œ±] [LocallyFiniteOrder Œ±] [DecidableEq Œ±]

variable {ùïú Œ±}

lemma mu'_spec_of_ne_left {a b : Œ±} (h : a ‚â† b) : ‚àë x in Icc a b, (mu' ùïú) x b = 0 := by
  have : mu' ùïú a b = _ := mu'_apply_of_ne h by_cases hab : a ‚â§ b
  ¬∑ rw [‚Üê add_sum_Ioc hab, this, neg_add_self]
  ¬∑ have : ‚àÄ x ‚àà Icc a b, ¬¨x ‚â§ b := by intro x hx hn; apply hab; rw [mem_Icc] at hx ;
      exact le_trans hx.1 hn
    conv in mu' _ _ _ => rw [apply_eq_zero_of_not_le (this x H)]
    exact sum_const_zero

end Mu'Spec

section MuZeta

variable (ùïú Œ±) [AddCommGroup ùïú] [MulOneClass ùïú] [PartialOrder Œ±] [LocallyFiniteOrder Œ±]
  [DecidableEq Œ±] [@DecidableRel Œ± (¬∑ ‚â§ ¬∑)]

lemma mu_mul_zeta : (mu ùïú * zeta ùïú : IncidenceAlgebra ùïú Œ±) = 1 := by
  ext a b
  rw [mul_apply, one_apply]
  split_ifs with he
  ¬∑ simp [he]
  ¬∑ simp only [mul_one, zeta_apply, mul_ite]
    conv in ite _ _ _ => rw [if_pos (mem_Icc.mp H).2]
    rw [mu_spec_of_ne_right he]

lemma zeta_mul_mu' : (zeta ùïú * mu' ùïú : IncidenceAlgebra ùïú Œ±) = 1 := by
  ext a b
  rw [mul_apply, one_apply]
  split_ifs with he
  ¬∑ simp [he]
  ¬∑ simp only [zeta_apply, one_mul, ite_mul]
    conv in ite _ _ _ => rw [if_pos (mem_Icc.mp H).1]
    rw [mu'_spec_of_ne_left he]

end MuZeta

section MuEqMu'

variable [Ring ùïú] [PartialOrder Œ±] [LocallyFiniteOrder Œ±] [DecidableEq Œ±]

lemma mu_eq_mu' : (mu ùïú : IncidenceAlgebra ùïú Œ±) = mu' ùïú :=
  left_inv_eq_right_inv (mu_mul_zeta _ _) (zeta_mul_mu' _ _)

lemma mu_apply_of_ne' {a b : Œ±} (h : a ‚â† b) : mu ùïú a b = -‚àë x in Ioc a b, mu ùïú x b := by
  rw [mu_eq_mu']; exact mu'_apply_of_ne h

lemma zeta_mul_mu [@DecidableRel Œ± (¬∑ ‚â§ ¬∑)] : (zeta ùïú * mu ùïú : IncidenceAlgebra ùïú Œ±) = 1 := by
  rw [mu_eq_mu']; exact zeta_mul_mu' _ _

lemma mu_spec_of_ne_left {a b : Œ±} (h : a ‚â† b) : ‚àë x in Icc a b, mu ùïú x b = 0 := by
  rw [mu_eq_mu', mu'_spec_of_ne_left h]

end MuEqMu'

section OrderDual

variable (ùïú) [Ring ùïú] [PartialOrder Œ±] [LocallyFiniteOrder Œ±] [DecidableEq Œ±]

@[simp]
lemma mu_toDual (a b : Œ±) : mu ùïú (toDual a) (toDual b) = mu ùïú b a := by
  letI : @DecidableRel Œ± (¬∑ ‚â§ ¬∑) := Classical.decRel _
  let mud : IncidenceAlgebra ùïú Œ±·µí·µà :=
    { toFun := fun a b => mu ùïú (of_dual b) (of_dual a)
      eq_zero_of_not_le' := fun a b hab => apply_eq_zero_of_not_le hab _ }
  suffices mu ùïú = mud by rw [this]; rfl
  suffices mud * zeta ùïú = 1 by
    rw [‚Üê mu_mul_zeta] at this
    apply_fun (¬∑ * mu ùïú) at this
    symm
    simpa [mul_assoc, zeta_mul_mu] using this
  clear a b
  ext a b
  simp only [mul_boole, one_apply, mul_apply, coe_mk, zeta_apply]
  obtain rfl | h := eq_or_ne a b
  ¬∑ simp
  ¬∑ rw [if_neg h]
    conv in ite _ _ _ => rw [if_pos (mem_Icc.mp H).2]
    change ‚àë x in Icc (of_dual b) (of_dual a), mu ùïú x a = 0
    exact mu_spec_of_ne_left h.symm

@[simp]
lemma mu_ofDual (a b : Œ±·µí·µà) : mu ùïú (ofDual a) (ofDual b) = mu ùïú b a :=
  (mu_toDual _ _ _).symm

end OrderDual

section InversionTop

variable {Œ±} [Ring ùïú] [PartialOrder Œ±] [OrderTop Œ±] [LocallyFiniteOrder Œ±] [DecidableEq Œ±] {a b : Œ±}

/-- A general form of M√∂bius inversion. Based on lemma 2.1.2 of Incidence Algebras by Spiegel and
O'Donnell. -/
lemma moebius_inversion_top (f g : Œ± ‚Üí ùïú) (h : ‚àÄ x, g x = ‚àë y in Ici x, f y) (x : Œ±) :
    f x = ‚àë y in Ici x, mu ùïú x y * g y := by
  letI : @DecidableRel Œ± (¬∑ ‚â§ ¬∑) := Classical.decRel _ <;> symm <;>
    calc
      ‚àë y in Ici x, mu ùïú x y * g y = ‚àë y in Ici x, mu ùïú x y * ‚àë z in Ici y, f z := by simp_rw [h]
      _ = ‚àë y in Ici x, mu ùïú x y * ‚àë z in Ici y, zeta ùïú y z * f z := by
        simp_rw [zeta_apply]
        conv in ite _ _ _ => rw [if_pos (mem_Ici.mp H)]
        simp
      _ = ‚àë y in Ici x, ‚àë z in Ici y, mu ùïú x y * zeta ùïú y z * f z := by simp [mul_sum]
      _ = ‚àë z in Ici x, ‚àë y in Icc x z, mu ùïú x y * zeta ùïú y z * f z := by
        erw [sum_sigma' (Ici x) fun y => Ici y]
        erw [sum_sigma' (Ici x) fun z => Icc x z]
        simp only [mul_boole, MulZeroClass.zero_mul, ite_mul, zeta_apply]
        refine' sum_bij (fun X hX => ‚ü®X.snd, X.fst‚ü©) _ _ _ _
        ¬∑ intro X hX
          simp only [mem_Ici, mem_sigma, mem_Icc] at *
          exact ‚ü®hX.1.trans hX.2, hX‚ü©
        ¬∑ intro X hX
          simp only at *
        ¬∑ intro X Y ha hb h
          simp [Sigma.ext_iff] at *
          rwa [and_comm']
        ¬∑ intro X hX
          use‚ü®X.snd, X.fst‚ü©
          simp only [and_true_iff, mem_Ici, eq_self_iff_true, Sigma.eta, mem_sigma, mem_Icc] at *
          exact hX.2
      _ = ‚àë z in Ici x, (mu ùïú * zeta ùïú) x z * f z := by
        conv in (mu _ * zeta _) _ _ => rw [mul_apply]
        simp_rw [sum_mul]
      _ = ‚àë y in Ici x, ‚àë z in Ici y, (1 : IncidenceAlgebra ùïú Œ±) x z * f z := by
        simp [mu_mul_zeta ùïú, ‚Üê add_sum_Ioi]
        conv in ite _ _ _ => rw [if_neg (ne_of_lt <| mem_Ioi.mp H)]
        conv in ite _ _ _ => rw [if_neg (not_lt_of_le <| (mem_Ioi.mp H).le)]
        simp
      _ = f x := by
        simp [one_apply, ‚Üê add_sum_Ioi]
        conv in ite _ _ _ => rw [if_neg (ne_of_lt <| mem_Ioi.mp H)]
        conv in ite _ _ _ => rw [if_neg (not_lt_of_le <| (mem_Ioi.mp H).le)]
        simp

end InversionTop

section InversionBot

variable [Ring ùïú] [PartialOrder Œ±] [OrderBot Œ±] [LocallyFiniteOrder Œ±] [DecidableEq Œ±]

/-- A general form of M√∂bius inversion. Based on lemma 2.1.3 of Incidence Algebras by Spiegel and
O'Donnell. -/
lemma moebius_inversion_bot (f g : Œ± ‚Üí ùïú) (h : ‚àÄ x, g x = ‚àë y in Iic x, f y) (x : Œ±) :
    f x = ‚àë y in Iic x, mu ùïú y x * g y := by
  convert @moebius_inversion_top ùïú Œ±·µí·µà _ _ _ _ _ f g h x
  ext y
  erw [mu_to_dual]

end InversionBot

section Prod

section Preorder

section Ring

variable (ùïú) [Ring ùïú] [Preorder Œ±] [Preorder Œ≤]

section DecidableLe

variable [DecidableRel ((¬∑ ‚â§ ¬∑) : Œ± ‚Üí Œ± ‚Üí Prop)] [DecidableRel ((¬∑ ‚â§ ¬∑) : Œ≤ ‚Üí Œ≤ ‚Üí Prop)]

lemma zeta_prod_apply (a b : Œ± √ó Œ≤) : zeta ùïú a b = zeta ùïú a.1 b.1 * zeta ùïú a.2 b.2 := by
  simp [ite_and, Prod.le_def]

lemma zeta_prod_mk (a‚ÇÅ a‚ÇÇ : Œ±) (b‚ÇÅ b‚ÇÇ : Œ≤) :
    zeta ùïú (a‚ÇÅ, b‚ÇÅ) (a‚ÇÇ, b‚ÇÇ) = zeta ùïú a‚ÇÅ a‚ÇÇ * zeta ùïú b‚ÇÅ b‚ÇÇ :=
  zeta_prod_apply _ _ _

end DecidableLe

variable {ùïú} (f f‚ÇÅ f‚ÇÇ : IncidenceAlgebra ùïú Œ±) (g g‚ÇÅ g‚ÇÇ : IncidenceAlgebra ùïú Œ≤)

/-- The cartesian product of two incidence algebras. -/
protected def prod : IncidenceAlgebra ùïú (Œ± √ó Œ≤)
    where
  toFun x y := f x.1 y.1 * g x.2 y.2
  eq_zero_of_not_le' x y hxy := by
    rw [Prod.le_def, not_and_or] at hxy
    cases hxy <;> simp [apply_eq_zero_of_not_le hxy]

lemma prod_mk (a‚ÇÅ a‚ÇÇ : Œ±) (b‚ÇÅ b‚ÇÇ : Œ≤) : f.Prod g (a‚ÇÅ, b‚ÇÅ) (a‚ÇÇ, b‚ÇÇ) = f a‚ÇÅ a‚ÇÇ * g b‚ÇÅ b‚ÇÇ :=
  rfl

@[simp]
lemma prod_apply (x y : Œ± √ó Œ≤) : f.Prod g x y = f x.1 y.1 * g x.2 y.2 :=
  rfl

/-- This is a version of `incidence_algebra.prod_mul_prod` that works over non-commutative rings. -/
lemma prod_mul_prod' [LocallyFiniteOrder Œ±] [LocallyFiniteOrder Œ≤]
    (h :
      ‚àÄ a‚ÇÅ a‚ÇÇ a‚ÇÉ b‚ÇÅ b‚ÇÇ b‚ÇÉ,
        f‚ÇÅ a‚ÇÅ a‚ÇÇ * g‚ÇÅ b‚ÇÅ b‚ÇÇ * (f‚ÇÇ a‚ÇÇ a‚ÇÉ * g‚ÇÇ b‚ÇÇ b‚ÇÉ) = f‚ÇÅ a‚ÇÅ a‚ÇÇ * f‚ÇÇ a‚ÇÇ a‚ÇÉ * (g‚ÇÅ b‚ÇÅ b‚ÇÇ * g‚ÇÇ b‚ÇÇ b‚ÇÉ)) :
    f‚ÇÅ.Prod g‚ÇÅ * f‚ÇÇ.Prod g‚ÇÇ = (f‚ÇÅ * f‚ÇÇ).Prod (g‚ÇÅ * g‚ÇÇ) := by ext x y hxy;
  simp [‚Üê prod_Icc, sum_mul_sum, h]

@[simp]
lemma one_prod_one [DecidableEq Œ±] [DecidableEq Œ≤] :
    (1 : IncidenceAlgebra ùïú Œ±).Prod (1 : IncidenceAlgebra ùïú Œ≤) = 1 := by ext x y hxy;
  simp [Prod.ext_iff, ite_and]

@[simp]
lemma zeta_prod_zeta [@DecidableRel Œ± (¬∑ ‚â§ ¬∑)] [@DecidableRel Œ≤ (¬∑ ‚â§ ¬∑)] :
    (zeta ùïú).Prod (zeta ùïú) = (zeta ùïú : IncidenceAlgebra ùïú (Œ± √ó Œ≤)) := by ext x y hxy;
  simp [hxy, hxy.1, hxy.2]

end Ring

section CommRing

variable [CommRing ùïú] [Preorder Œ±] [Preorder Œ≤] [LocallyFiniteOrder Œ±] [LocallyFiniteOrder Œ≤]
  (f‚ÇÅ f‚ÇÇ : IncidenceAlgebra ùïú Œ±) (g‚ÇÅ g‚ÇÇ : IncidenceAlgebra ùïú Œ≤)

@[simp]
lemma prod_mul_prod : f‚ÇÅ.Prod g‚ÇÅ * f‚ÇÇ.Prod g‚ÇÇ = (f‚ÇÅ * f‚ÇÇ).Prod (g‚ÇÅ * g‚ÇÇ) :=
  prod_mul_prod' _ _ _ _ fun _ _ _ _ _ _ => mul_mul_mul_comm _ _ _ _

end CommRing

end Preorder

section PartialOrder

variable (ùïú) [Ring ùïú] [PartialOrder Œ±] [PartialOrder Œ≤] [LocallyFiniteOrder Œ±]
  [LocallyFiniteOrder Œ≤] [DecidableEq Œ±] [DecidableEq Œ≤] [DecidableRel ((¬∑ ‚â§ ¬∑) : Œ± ‚Üí Œ± ‚Üí Prop)]
  [DecidableRel ((¬∑ ‚â§ ¬∑) : Œ≤ ‚Üí Œ≤ ‚Üí Prop)]

/-- The M√∂bius function on a product order. Based on lemma 2.1.13 of Incidence Algebras by Spiegel and O'Donnell. -/
@[simp]
lemma mu_prod_mu : (mu ùïú).Prod (mu ùïú) = (mu ùïú : IncidenceAlgebra ùïú (Œ± √ó Œ≤)) := by
  refine' left_inv_eq_right_inv _ zeta_mul_mu
  rw [‚Üê zeta_prod_zeta, prod_mul_prod', mu_mul_zeta, mu_mul_zeta, one_prod_one]
  refine' fun _ _ _ _ _ _ => Commute.mul_mul_mul_comm _ _ _
  dsimp
  split_ifs <;> simp

end PartialOrder

end Prod

section Euler

variable [AddCommGroup ùïú] [One ùïú] [Preorder Œ±] [BoundedOrder Œ±] [LocallyFiniteOrder Œ±]
  [DecidableEq Œ±]

/-- The Euler characteristic of a finite bounded order. -/
def eulerChar : ùïú :=
  mu ùïú (‚ä• : Œ±) ‚ä§

end Euler

end IncidenceAlgebra
